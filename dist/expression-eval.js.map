{"version":3,"file":"expression-eval.js","sources":["../index.js"],"sourcesContent":["const jsep = require('jsep');\r\n\r\n/**\r\n * Evaluation code from JSEP project, under MIT License.\r\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\r\n */\r\n\r\nconst binops = {\r\n  '||':  function (a, b) { return a || b; },\r\n  '&&':  function (a, b) { return a && b; },\r\n  '|':   function (a, b) { return a | b; },\r\n  '^':   function (a, b) { return a ^ b; },\r\n  '&':   function (a, b) { return a & b; },\r\n  '==':  function (a, b) { return a == b; }, // jshint ignore:line\r\n  '!=':  function (a, b) { return a != b; }, // jshint ignore:line\r\n  '===': function (a, b) { return a === b; },\r\n  '!==': function (a, b) { return a !== b; },\r\n  '<':   function (a, b) { return a < b; },\r\n  '>':   function (a, b) { return a > b; },\r\n  '<=':  function (a, b) { return a <= b; },\r\n  '>=':  function (a, b) { return a >= b; },\r\n  '<<':  function (a, b) { return a << b; },\r\n  '>>':  function (a, b) { return a >> b; },\r\n  '>>>': function (a, b) { return a >>> b; },\r\n  '+':   function (a, b) { return a + b; },\r\n  '-':   function (a, b) { return a - b; },\r\n  '*':   function (a, b) { return a * b; },\r\n  '/':   function (a, b) { return a / b; },\r\n  '%':   function (a, b) { return a % b; }\r\n};\r\n\r\nconst unops = {\r\n  '-' :  function (a) { return -a; },\r\n  '+' :  function (a) { return +a; },\r\n  '~' :  function (a) { return ~a; },\r\n  '!' :  function (a) { return !a; },\r\n};\r\n\r\nfunction evaluateArray ( list, context ) {\r\n  return list.map(function (v) { return evaluate(v, context); });\r\n}\r\n\r\nasync function evaluateArrayAsync( list, context ) {\r\n  const res = await Promise.all(list.map((v) => evaluateAsync(v, context)));\r\n  return res;\r\n}\r\n\r\nfunction evaluateMember ( node, context ) {\r\n  const object = evaluate(node.object, context);\r\n  if ( node.computed ) {\r\n    return [object, object[evaluate(node.property, context)]];\r\n  } else {\r\n    return [object, object[node.property.name]];\r\n  }\r\n}\r\n\r\nasync function evaluateMemberAsync( node, context ) {\r\n  const object = await evaluateAsync(node.object, context);\r\n  if (  node.computed) {\r\n    return [object, object[await evaluateAsync(node.property, context)]];\r\n  } else {\r\n    return [object, object[node.property.name]];\r\n  }\r\n}\r\n\r\nfunction evaluate ( node, context ) {\r\n\r\n  switch ( node.type ) {\r\n\r\n    case 'ArrayExpression':\r\n      return evaluateArray( node.elements, context );\r\n\r\n    case 'BinaryExpression':\r\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\r\n\r\n    case 'CallExpression':\r\n      let caller, fn, assign;\r\n      if (node.callee.type === 'MemberExpression') {\r\n        assign = evaluateMember( node.callee, context );\r\n        caller = assign[0];\r\n        fn = assign[1];\r\n      } else {\r\n        fn = evaluate( node.callee, context );\r\n      }\r\n      if (typeof fn  !== 'function') { return undefined; }\r\n      return fn.apply( caller, evaluateArray( node.arguments, context ) );\r\n\r\n    case 'ConditionalExpression':\r\n      return evaluate( node.test, context )\r\n        ? evaluate( node.consequent, context )\r\n        : evaluate( node.alternate, context );\r\n\r\n    case 'Identifier':\r\n      return context[node.name];\r\n\r\n    case 'Literal':\r\n      return node.value;\r\n\r\n    case 'LogicalExpression':\r\n      if (node.operator === '||') {\r\n        return evaluate( node.left, context ) || evaluate( node.right, context );\r\n      } else if (node.operator === '&&') {\r\n        return evaluate( node.left, context ) && evaluate( node.right, context );\r\n      }\r\n      return binops[ node.operator ]( evaluate( node.left, context ), evaluate( node.right, context ) );\r\n\r\n    case 'MemberExpression':\r\n      return evaluateMember(node, context)[1];\r\n\r\n    case 'ThisExpression':\r\n      return context;\r\n\r\n    case 'UnaryExpression':\r\n      return unops[ node.operator ]( evaluate( node.argument, context ) );\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n\r\n}\r\n\r\nasync function evaluateAsync( node, context ) {\r\n\r\n  switch ( node.type ) {\r\n\r\n    case 'ArrayExpression':\r\n      return await evaluateArrayAsync( node.elements, context );\r\n\r\n    case 'BinaryExpression': {\r\n      const [left, right] = await Promise.all([\r\n        evaluateAsync( node.left, context ),\r\n        evaluateAsync( node.right, context )\r\n      ]);\r\n      return binops[ node.operator ]( left, right );\r\n    }\r\n\r\n    case 'CallExpression':\r\n      let caller, fn, assign;\r\n      if (node.callee.type === 'MemberExpression') {\r\n        assign = await evaluateMemberAsync( node.callee, context );\r\n        caller = assign[0];\r\n        fn = assign[1];\r\n      } else {\r\n        fn = await evaluateAsync( node.callee, context );\r\n      }\r\n      if (typeof fn !== 'function') {\r\n        return undefined;\r\n      }\r\n      return await fn.apply(\r\n        caller,\r\n        await evaluateArrayAsync( node.arguments, context )\r\n      );\r\n\r\n    case 'ConditionalExpression':\r\n      return (await evaluateAsync( node.test, context ))\r\n        ? await evaluateAsync( node.consequent, context )\r\n        : await evaluateAsync( node.alternate, context );\r\n\r\n    case 'Identifier':\r\n      return context[node.name];\r\n\r\n    case 'Literal':\r\n      return node.value;\r\n\r\n    case 'LogicalExpression': {\r\n      if (node.operator === '||') {\r\n        return (\r\n          (await evaluateAsync( node.left, context )) ||\r\n          (await evaluateAsync( node.right, context ))\r\n        );\r\n      } else if (node.operator === '&&') {\r\n        return (\r\n          (await evaluateAsync( node.left, context )) &&\r\n          (await evaluateAsync( node.right, context ))\r\n        );\r\n      }\r\n\r\n      const [left, right] = await Promise.all([\r\n        evaluateAsync( node.left, context ),\r\n        evaluateAsync( node.right, context )\r\n      ]);\r\n\r\n      return binops[ node.operator ]( left, right );\r\n    }\r\n\r\n    case 'MemberExpression':\r\n      return (await evaluateMemberAsync(node, context))[1];\r\n\r\n    case 'ThisExpression':\r\n      return context;\r\n\r\n    case 'UnaryExpression':\r\n      return unops[ node.operator ](await evaluateAsync( node.argument, context ));\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\nfunction compile (expression) {\r\n  return evaluate.bind(null, jsep(expression));\r\n}\r\n\r\nfunction compileAsync(expression) {\r\n  return evaluateAsync.bind(null, jsep(expression));\r\n}\r\n\r\nmodule.exports = {\r\n  parse: jsep,\r\n  eval: evaluate,\r\n  evalAsync: evaluateAsync,\r\n  compile: compile,\r\n  compileAsync: compileAsync\r\n};\r\n"],"names":["evaluateAsync","node","context","fn","_fn","apply","caller","evaluateArrayAsync","arguments","type","elements","Promise","all","left","right","binops","operator","assign","callee","evaluateMemberAsync","test","consequent","alternate","name","value","_evaluateMemberAsync2","unops","argument","undefined","object","computed","property","list","map","v","jsep","require","a","b","evaluateArray","evaluate","evaluateMember","module","exports","parse","eval","evalAsync","compile","expression","bind","compileAsync"],"mappings":"IAyHeA,WAAeC,EAAMC,gCAwBZ,mBAAPC,SAGEA,IAAAC,EAAGC,QACdC,yBACMC,EAAoBN,EAAKO,UAAWN,qEA3BvCD,EAAKQ,UAEP,yCACUF,EAAoBN,EAAKS,SAAUR,QAE7C,0CACyBS,QAAQC,IAAI,CACtCZ,EAAeC,EAAKY,KAAMX,GAC1BF,EAAeC,EAAKa,MAAOZ,8BAEtBa,EAAQd,EAAKe,2BAGjB,qBACCV,EAAQH,EAAIc,IACS,qBAArBhB,EAAKiB,OAAOT,qBACCU,EAAqBlB,EAAKiB,OAAQhB,qBACjDI,GADAW,KACgB,GAChBd,EAAKc,EAAO,qBAEDjB,EAAeC,EAAKiB,OAAQhB,qBAAvCC,0DAUC,+CACWH,EAAeC,EAAKmB,KAAMlB,4CAC9BF,IAAeC,EAAKoB,WACLpB,EAAKqB,UADYpB,UAGvC,oCACIA,EAAQD,EAAKsB,WAEjB,iCACItB,EAAKuB,WAET,8DAayBb,QAAQC,IAAI,CACtCZ,EAAeC,EAAKY,KAAMX,GAC1BF,EAAeC,EAAKa,MAAOZ,8BAGtBa,EAAQd,EAAKe,6BAjBE,OAAlBf,EAAKe,+BAEEhB,EAAeC,EAAKY,KAAMX,+CAC1BF,EAAeC,EAAKa,MAAOZ,qBAET,OAAlBD,EAAKe,qCAELhB,EAAeC,EAAKY,KAAMX,8CAC1BF,EAAeC,EAAKa,MAAOZ,gEAYnC,0CACWiB,EAAoBlB,EAAMC,4BAAjCuB,EAA2C,SAE/C,wCACIvB,OAEJ,wBACIwB,EAAOzB,EAAKe,iCAAiBhB,EAAeC,EAAK0B,SAAUzB,mCAA3DwB,2CAGAE,wCA3IET,WAAqBlB,EAAMC,8BACnBF,EAAcC,EAAK4B,OAAQ3B,kBAA1C2B,UACA5B,EAAK6B,yBACoB9B,EAAcC,EAAK8B,SAAU7B,2BAAnD,CAAC2B,EAAQA,QAET,CAACA,EAAQA,EAAO5B,EAAK8B,SAASR,6CAnB1BhB,WAAoByB,EAAM9B,8BACrBS,QAAQC,IAAIoB,EAAKC,aAAKC,UAAMlC,EAAckC,EAAGhC,2CA3C3DiC,EAAOC,QAAQ,QAOfrB,EAAS,MACN,SAAUsB,EAAGC,UAAYD,GAAKC,QAC9B,SAAUD,EAAGC,UAAYD,GAAKC,OAC9B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,QAC7B,SAAUD,EAAGC,UAAYD,GAAKC,QAC9B,SAAUD,EAAGC,UAAYD,GAAKC,SAC9B,SAAUD,EAAGC,UAAYD,IAAMC,SAC/B,SAAUD,EAAGC,UAAYD,IAAMC,OAC/B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,QAC7B,SAAUD,EAAGC,UAAYD,GAAKC,QAC9B,SAAUD,EAAGC,UAAYD,GAAKC,QAC9B,SAAUD,EAAGC,UAAYD,GAAKC,QAC9B,SAAUD,EAAGC,UAAYD,GAAKC,SAC9B,SAAUD,EAAGC,UAAYD,IAAMC,OAC/B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,OAC7B,SAAUD,EAAGC,UAAYD,EAAIC,IAGhCZ,EAAQ,KACL,SAAUW,UAAaA,OACvB,SAAUA,UAAaA,OACvB,SAAUA,UAAaA,OACvB,SAAUA,UAAaA,IAGhC,SAASE,EAAgBP,EAAM9B,UACtB8B,EAAKC,IAAI,SAAUC,UAAYM,EAASN,EAAGhC,KAQpD,SAASuC,EAAiBxC,EAAMC,OACxB2B,EAASW,EAASvC,EAAK4B,OAAQ3B,UAChCD,EAAK6B,SACD,CAACD,EAAQA,EAAOW,EAASvC,EAAK8B,SAAU7B,KAExC,CAAC2B,EAAQA,EAAO5B,EAAK8B,SAASR,OAazC,SAASiB,EAAWvC,EAAMC,UAEfD,EAAKQ,UAEP,yBACI8B,EAAetC,EAAKS,SAAUR,OAElC,0BACIa,EAAQd,EAAKe,UAAYwB,EAAUvC,EAAKY,KAAMX,GAAWsC,EAAUvC,EAAKa,MAAOZ,QAEnF,qBACCI,EAAQH,EAAIc,KACS,qBAArBhB,EAAKiB,OAAOT,MAEdH,GADAW,EAASwB,EAAgBxC,EAAKiB,OAAQhB,IACtB,GAChBC,EAAKc,EAAO,IAEZd,EAAKqC,EAAUvC,EAAKiB,OAAQhB,GAEX,mBAARC,gBACJA,EAAGE,MAAOC,EAAQiC,EAAetC,EAAKO,UAAWN,QAErD,+BACIsC,EAAUvC,EAAKmB,KAAMlB,GACxBsC,EAAUvC,EAAKoB,WAAYnB,GAC3BsC,EAAUvC,EAAKqB,UAAWpB,OAE3B,oBACIA,EAAQD,EAAKsB,UAEjB,iBACItB,EAAKuB,UAET,0BACmB,OAAlBvB,EAAKe,SACAwB,EAAUvC,EAAKY,KAAMX,IAAasC,EAAUvC,EAAKa,MAAOZ,GACpC,OAAlBD,EAAKe,SACPwB,EAAUvC,EAAKY,KAAMX,IAAasC,EAAUvC,EAAKa,MAAOZ,GAE1Da,EAAQd,EAAKe,UAAYwB,EAAUvC,EAAKY,KAAMX,GAAWsC,EAAUvC,EAAKa,MAAOZ,QAEnF,0BACIuC,EAAexC,EAAMC,GAAS,OAElC,wBACIA,MAEJ,yBACIwB,EAAOzB,EAAKe,UAAYwB,EAAUvC,EAAK0B,SAAUzB,oBA8F9DwC,OAAOC,QAAU,CACfC,MAAOT,EACPU,KAAML,EACNM,UAAW9C,EACX+C,QAZF,SAAkBC,UACTR,EAASS,KAAK,KAAMd,EAAKa,KAYhCE,aATF,SAAsBF,UACbhD,EAAciD,KAAK,KAAMd,EAAKa"}