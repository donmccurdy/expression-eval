{"version":3,"file":"expression-eval.module.js","sources":["../index.js"],"sourcesContent":["import jsep from 'jsep';\n\n/**\n * Evaluation code from JSEP project, under MIT License.\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\n */\n\nconst binops = {\n  '||':  function (a, b) { return a || b; },\n  '&&':  function (a, b) { return a && b; },\n  '|':   function (a, b) { return a | b; },\n  '^':   function (a, b) { return a ^ b; },\n  '&':   function (a, b) { return a & b; },\n  '==':  function (a, b) { return a == b; }, // jshint ignore:line\n  '!=':  function (a, b) { return a != b; }, // jshint ignore:line\n  '===': function (a, b) { return a === b; },\n  '!==': function (a, b) { return a !== b; },\n  '<':   function (a, b) { return a < b; },\n  '>':   function (a, b) { return a > b; },\n  '<=':  function (a, b) { return a <= b; },\n  '>=':  function (a, b) { return a >= b; },\n  '<<':  function (a, b) { return a << b; },\n  '>>':  function (a, b) { return a >> b; },\n  '>>>': function (a, b) { return a >>> b; },\n  '+':   function (a, b) { return a + b; },\n  '-':   function (a, b) { return a - b; },\n  '*':   function (a, b) { return a * b; },\n  '/':   function (a, b) { return a / b; },\n  '%':   function (a, b) { return a % b; }\n};\n\nconst unops = {\n  '-' :  function (a) { return -a; },\n  '+' :  function (a) { return +a; },\n  '~' :  function (a) { return ~a; },\n  '!' :  function (a) { return !a; },\n};\n\nfunction evaluate(node, context, options) {\n  return evaluateNode(node)\n\n  function evaluateArray(list) {\n    return list.map(function (v) {\n      return evaluateNode(v);\n    });\n  }\n\n  function evaluateMember(node) {\n    const object = evaluateNode(node.object);\n    if (node.computed) {\n      const evaluated = evaluateNode(node.property)\n      assertInObject(evaluated, object, options)\n      return [object, object[evaluated]];\n    } else {\n      assertInObject(node.property.name, object, options)\n      return [object, object[node.property.name]];\n    }\n  }\n\n  function evaluateNode(node) {\n    switch (node.type) {\n\n      case 'ArrayExpression':\n        return evaluateArray(node.elements);\n\n      case 'BinaryExpression':\n        return binops[node.operator](evaluateNode(node.left), evaluateNode(node.right));\n\n      case 'CallExpression':\n        let caller, fn, assign;\n        if (node.callee.type === 'MemberExpression') {\n          assign = evaluateMember(node.callee);\n          caller = assign[0];\n          fn = assign[1];\n        } else {\n          fn = evaluateNode(node.callee);\n        }\n        if (typeof fn !== 'function') {\n          return undefined;\n        }\n        return fn.apply(caller, evaluateArray(node.arguments));\n\n      case 'ConditionalExpression':\n        return evaluateNode(node.test)\n            ? evaluateNode(node.consequent)\n            : evaluateNode(node.alternate);\n\n      case 'Identifier':\n        assertInObject(node.name, context, options)\n        return context[node.name];\n\n      case 'Literal':\n        return node.value;\n\n      case 'LogicalExpression':\n        if (node.operator === '||') {\n          return evaluateNode(node.left) || evaluateNode(node.right);\n        } else if (node.operator === '&&') {\n          return evaluateNode(node.left) && evaluateNode(node.right);\n        }\n        return binops[node.operator](evaluateNode(node.left), evaluateNode(node.right));\n\n      case 'MemberExpression':\n        return evaluateMember(node)[1];\n\n      case 'ThisExpression':\n        return context;\n\n      case 'UnaryExpression':\n        return unops[node.operator](evaluateNode(node.argument));\n\n      default:\n        return undefined;\n    }\n  }\n}\n\nasync function evalAsync(node, context, options) {\n  return await evaluateNode(node)\n\n  async function evaluateArray(list) {\n    const res = await Promise.all(list.map((v) => evaluateNode(v)));\n    return res;\n  }\n\n  async function evaluateMember(node) {\n    const object = await evaluateNode(node.object);\n    if (node.computed) {\n      const evaluated = await evaluateNode(node.property)\n      assertInObject(evaluated, object, options)\n      return [object, object[evaluated]];\n    } else {\n      assertInObject(node.property.name, object, options)\n      return [object, object[node.property.name]];\n    }\n  }\n\n  async function evaluateNode(node) {\n    switch (node.type) {\n\n      case 'ArrayExpression':\n        return await evaluateArray(node.elements);\n\n      case 'BinaryExpression': {\n        const [left, right] = await Promise.all([\n          evaluateNode(node.left),\n          evaluateNode(node.right)\n        ]);\n        return binops[node.operator](left, right);\n      }\n\n      case 'CallExpression':\n        let caller, fn, assign;\n        if (node.callee.type === 'MemberExpression') {\n          assign = await evaluateMember(node.callee);\n          caller = assign[0];\n          fn = assign[1];\n        } else {\n          fn = await evaluateNode(node.callee);\n        }\n        if (typeof fn !== 'function') {\n          return undefined;\n        }\n        return await fn.apply(\n            caller,\n            await evaluateArray(node.arguments)\n        );\n\n      case 'ConditionalExpression':\n        return (await evaluateNode(node.test))\n            ? await evaluateNode(node.consequent)\n            : await evaluateNode(node.alternate);\n\n      case 'Identifier':\n        assertInObject(node.name, context, options)\n        return context[node.name];\n\n      case 'Literal':\n        return node.value;\n\n      case 'LogicalExpression': {\n        if (node.operator === '||') {\n          return (\n              (await evaluateNode(node.left)) || (await evaluateNode(node.right))\n          );\n        } else if (node.operator === '&&') {\n          return (\n              (await evaluateNode(node.left)) && (await evaluateNode(node.right))\n          );\n        }\n\n        const [left, right] = await Promise.all([\n          evaluateNode(node.left),\n          evaluateNode(node.right)\n        ]);\n\n        return binops[node.operator](left, right);\n      }\n\n      case 'MemberExpression':\n        return (await evaluateMember(node))[1];\n\n      case 'ThisExpression':\n        return context;\n\n      case 'UnaryExpression':\n        return unops[node.operator](await evaluateNode(node.argument));\n\n      default:\n        return undefined;\n    }\n  }\n}\n\nfunction compile(expression) {\n  return evaluate.bind(null, jsep(expression));\n}\n\nfunction compileAsync(expression) {\n  return evalAsync.bind(null, jsep(expression));\n}\n\n// Added functions to inject Custom Unary Operators (and override existing ones)\nfunction addUnaryOp(operator, _function) {\n  jsep.addUnaryOp(operator);\n  unops[operator] = _function;\n}\n\n// Added functions to inject Custom Binary Operators (and override existing ones)\nfunction addBinaryOp(operator, _function) {\n  jsep.addBinaryOp(operator);\n  binops[operator] = _function;\n}\n\nfunction assertInObject(name, object, options = {strict: false}) {\n  if (options.strict && !Object.keys(object).includes(name)) {\n    throw new Error(`${name} is not defined`)\n  }\n}\n\nexport {\n  jsep as parse,\n  evaluate as eval,\n  evalAsync,\n  compile,\n  compileAsync,\n  addUnaryOp,\n  addBinaryOp\n};\n"],"names":["evalAsync","node","context","options","evaluateNode","fn","_fn","apply","caller","evaluateArray","arguments","type","elements","Promise","all","left","right","binops","operator","assign","callee","evaluateMember","test","consequent","alternate","assertInObject","name","value","_evaluateMember2","unops","argument","undefined","object","computed","property","evaluated","list","map","v","a","b","evaluate","compile","expression","bind","jsep","compileAsync","addUnaryOp","_function","addBinaryOp","strict","Object","keys","includes","Error"],"mappings":"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"}